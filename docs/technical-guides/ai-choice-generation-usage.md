# AI Choice Generation & Custom Input Usage Guide

This guide covers how to integrate and use the AI choice generation system with custom player input functionality in your Narraitor components.

## Overview

The choice system supports two types of player input:
1. **AI-Generated Choices**: 3-4 contextual options generated by the AI
2. **Custom Player Input**: Free-text input allowing players to type their own actions

Both types integrate seamlessly with the narrative generation system.

## Quick Start

The easiest way to use AI choice generation is through the `GameSessionActiveWithNarrative` component:

```tsx
import { GameSessionActiveWithNarrative } from '@/components/GameSession';

function YourGameComponent() {
  return (
    <GameSessionActiveWithNarrative
      worldId="your-world-id"
      sessionId="your-session-id"
      onChoiceSelected={(choiceId) => {
        console.log('Player selected choice:', choiceId);
        // This automatically triggers new narrative generation
      }}
    />
  );
}
```

## Advanced Integration

### Manual Choice Generation

If you need more control over when choices are generated, use the `NarrativeController` directly:

```tsx
import { NarrativeController } from '@/components/Narrative';
import { Decision } from '@/types/narrative.types';

function CustomNarrativeComponent() {
  const [currentChoices, setCurrentChoices] = useState<Decision | null>(null);

  const handleChoicesGenerated = (decision: Decision) => {
    setCurrentChoices(decision);
    console.log('Generated choices:', decision.options);
  };

  return (
    <>
      <NarrativeController
        worldId="your-world-id"
        sessionId="your-session-id"
        generateChoices={true}
        onChoicesGenerated={handleChoicesGenerated}
      />
      
      {currentChoices && (
        <div>
          <h3>{currentChoices.prompt}</h3>
          {currentChoices.options.map((option) => (
            <button key={option.id} onClick={() => selectChoice(option.id)}>
              {option.text}
            </button>
          ))}
        </div>
      )}
    </>
  );
}
```

### Using the Choice Generator Service Directly

For complete custom control, use the `ChoiceGenerator` service:

```tsx
import { narrativeStore } from '@/state/narrativeStore';

async function generateCustomChoices(worldId: string, sessionId: string) {
  // Get recent narrative context
  const segments = narrativeStore.getState().getSessionSegments(sessionId);
  const recentSegments = segments.slice(-5); // Last 5 segments
  
  // Create narrative context
  const narrativeContext = {
    recentSegments,
    currentLocation: 'Custom Location',
    // Add more context as needed
  };
  
  try {
    // Use secure API endpoint instead of direct AI client
    const response = await fetch('/api/narrative/choices', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        worldId,
        narrativeContext,
        characterIds: [], // Add character IDs if available
        maxOptions: 4,
        minOptions: 3
      }),
    });

    if (!response.ok) {
      throw new Error('Failed to generate choices');
    }

    const decision = await response.json();
    console.log('Generated decision:', decision);
    return decision;
  } catch (error) {
    console.error('Failed to generate choices:', error);
    // Handle error gracefully
    return null;
  }
}
```

## Configuration Options

### Choice Generation Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `worldId` | string | required | ID of the world for context |
| `narrativeContext` | NarrativeContext | required | Recent story segments and context |
| `characterIds` | string[] | `[]` | Character IDs for personalization |
| `maxOptions` | number | `4` | Maximum number of choices to generate |
| `minOptions` | number | `3` | Minimum number of choices (fallbacks added if needed) |

### Narrative Context Structure

```typescript
interface NarrativeContext {
  recentSegments?: NarrativeSegment[];
  currentLocation?: string;
  world?: World;
  // Additional context properties
}
```

## Error Handling

The choice generation system includes comprehensive error handling:

### Automatic Fallbacks

If AI generation fails, the system provides default choices:

```typescript
// These fallback choices are automatically used when AI fails
const fallbackChoices = [
  { id: 'fallback-1', text: 'Investigate the area more carefully' },
  { id: 'fallback-2', text: 'Talk to someone nearby' },
  { id: 'fallback-3', text: 'Move to a different location' }
];
```

### Custom Error Handling

```tsx
const handleChoicesGenerated = (decision: Decision) => {
  if (!decision || decision.options.length === 0) {
    // Handle empty decision
    console.warn('No choices generated, using fallback system');
    return;
  }
  
  // Process valid decision
  setCurrentChoices(decision);
};
```

## Performance Optimization

### Context Management

Limit the narrative context to improve performance:

```tsx
// Use only the most recent segments for context
const contextSegments = allSegments.slice(-3); // Last 3 segments

// Or filter by relevance
const relevantSegments = allSegments.filter(segment => 
  segment.type === 'scene' || segment.type === 'dialogue'
);
```

### Caching Strategies

Consider implementing caching for repeated requests:

```typescript
const choiceCache = new Map<string, Decision>();

function getCachedChoices(contextKey: string): Decision | null {
  return choiceCache.get(contextKey) || null;
}

function setCachedChoices(contextKey: string, decision: Decision): void {
  choiceCache.set(contextKey, decision);
}
```

## Testing Your Integration

### Development Testing

1. **Use the dev harness**: Navigate to `/dev/narrative-system` to test choice generation
2. **Enable debug logging**: Temporarily add console.log statements to trace the generation flow
3. **Test error scenarios**: Disconnect internet to test fallback mechanisms

### Unit Testing Example

```typescript
// ❌ OLD PATTERN - Testing direct AI clients (deprecated)
// Use API endpoint testing instead

// ✅ NEW SECURE PATTERN - Test API endpoints
describe('AI Choice Generation API', () => {
  beforeEach(() => {
    global.fetch = jest.fn();
  });
  
  afterEach(() => {
    jest.restoreAllMocks();
  });

  test('generates choices with valid context via API', async () => {
    const mockResponse = {
      id: 'test-decision',
      prompt: 'What do you want to do?',
      options: [
        { id: 'choice-1', text: 'Explore the cave' },
        { id: 'choice-2', text: 'Turn back' },
        { id: 'choice-3', text: 'Light a torch' }
      ]
    };
    
    (global.fetch as jest.Mock).mockResolvedValue({
      ok: true,
      json: async () => mockResponse
    });
    
    const response = await fetch('/api/narrative/choices', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        worldId: 'test-world',
        narrativeContext: {
          recentSegments: [
            { content: 'You enter a dark cave...', type: 'scene' }
          ]
        },
        characterIds: []
      })
    });
    
    const result = await response.json();
    
    expect(result.options).toHaveLength(3);
    expect(result.prompt).toBeTruthy();
  });
});
```

## Best Practices

### 1. Context Quality

Provide rich, recent narrative context:

```tsx
// GOOD: Recent, relevant context
const context = {
  recentSegments: segments.slice(-5),
  currentLocation: currentLocation,
  world: worldData
};

// AVOID: Too much context or stale data
const context = {
  recentSegments: segments, // All segments - can be too much
  // Missing location and world data
};
```

### 2. Error Resilience

Always handle errors gracefully:

```tsx
const generateChoices = async () => {
  try {
    const choices = await choiceGenerator.generateChoices(params);
    if (choices && choices.options.length > 0) {
      setChoices(choices);
    } else {
      // Use fallback system
      setChoices(generateFallbackChoices());
    }
  } catch (error) {
    console.error('Choice generation failed:', error);
    setChoices(generateFallbackChoices());
  }
};
```

### 3. User Experience

Provide loading feedback:

```tsx
function ChoiceComponent() {
  const [isGenerating, setIsGenerating] = useState(false);
  const [choices, setChoices] = useState<Decision | null>(null);

  const generateChoices = async () => {
    setIsGenerating(true);
    try {
      const result = await choiceGenerator.generateChoices(params);
      setChoices(result);
    } finally {
      setIsGenerating(false);
    }
  };

  return (
    <div>
      {isGenerating ? (
        <div>Generating your choices...</div>
      ) : choices ? (
        <ChoiceSelector decision={choices} />
      ) : (
        <div>No choices available</div>
      )}
    </div>
  );
}
```

## Common Patterns

### Pattern 1: Auto-Generation After Narrative

```tsx
const handleNarrativeGenerated = (segment: NarrativeSegment) => {
  // Automatically generate choices after narrative
  generatePlayerChoices();
};
```

### Pattern 2: Manual Choice Trigger

```tsx
const onPlayerAction = (action: string) => {
  if (action === 'need-choices') {
    generatePlayerChoices();
  }
};
```

### Pattern 3: Conditional Generation

```tsx
const shouldGenerateChoices = (segment: NarrativeSegment) => {
  return segment.type === 'scene' || segment.type === 'dialogue';
};
```

## Troubleshooting

### Common Issues

1. **No choices generated**: Check that narrative context is provided
2. **Slow generation**: Reduce context size or implement caching
3. **Irrelevant choices**: Ensure world data is included in context
4. **Crashes on errors**: Implement proper error boundaries

### Debug Checklist

- [ ] World ID is valid and world exists in store
- [ ] Narrative context contains recent segments
- [ ] AI client is properly configured
- [ ] Error handling is implemented
- [ ] Fallback mechanisms are working

## Custom Player Input Integration

### Using ChoiceSelector with Custom Input

The `ChoiceSelector` component supports both AI-generated choices and custom player input:

```tsx
import { ChoiceSelector } from '@/components/shared/ChoiceSelector';

function CustomChoiceExample() {
  const handleCustomSubmit = (customText: string) => {
    console.log('Player typed:', customText);
    
    // Create custom decision option
    const customOption = {
      id: generateUniqueId('custom'),
      text: customText,
      isCustomInput: true,
    };
    
    // Process custom action same as predefined choice
    processPlayerChoice(customOption.id);
  };

  return (
    <ChoiceSelector
      decision={currentDecision}
      onSelect={handleChoiceSelect}
      enableCustomInput={true}
      onCustomSubmit={handleCustomSubmit}
      customInputPlaceholder="Describe your action..."
      maxCustomLength={250}
    />
  );
}
```

### Custom Input Configuration

```tsx
// Basic custom input
<ChoiceSelector
  enableCustomInput={true}
  onCustomSubmit={handleCustomInput}
/>

// Advanced configuration
<ChoiceSelector
  enableCustomInput={true}
  onCustomSubmit={handleCustomInput}
  customInputPlaceholder="What do you do?"
  maxCustomLength={150}
  isDisabled={isGenerating}
/>
```

### Handling Custom Input in Game Sessions

```tsx
function GameSessionWithCustomInput() {
  const handleCustomSubmit = async (customText: string) => {
    // Add custom option to current decision
    const customChoiceId = generateUniqueId('custom');
    const updatedDecision = {
      ...currentDecision,
      options: [...currentDecision.options, {
        id: customChoiceId,
        text: customText,
        isCustomInput: true,
      }],
      selectedOptionId: customChoiceId
    };
    
    // Update narrative store
    narrativeStore.getState().updateDecision(currentDecision.id, updatedDecision);
    
    // Trigger narrative generation
    await generateNextNarrativeSegment(customChoiceId);
  };

  return (
    <ActiveGameSession
      worldId={worldId}
      sessionId={sessionId}
      onChoiceSelected={handleChoiceSelected}
      customInputHandler={handleCustomSubmit}
    />
  );
}
```

### Custom Input Timing & Flow

The system handles custom input with special timing considerations:

1. **Custom Input Submission**: Player types and submits custom action
2. **Narrative Generation**: AI incorporates custom action into story (~3-5 seconds)
3. **Choice Regeneration**: New suggested actions appear after delay (~2 seconds)
4. **Continued Play**: Player can use either custom input or suggested actions

```tsx
// The narrative controller automatically handles timing
const NarrativeController = () => {
  const generateNextSegment = async (choiceId: string) => {
    // Detect if choice was custom input
    const isCustomInput = choiceId.startsWith('custom_');
    
    // Generate narrative incorporating the choice
    await generateNarrative(choiceId);
    
    // Generate new choices with appropriate delay
    if (isCustomInput) {
      // Longer delay after custom input
      setTimeout(() => generateChoices(), 2000);
    } else {
      // Normal delay after predefined choice
      setTimeout(() => generateChoices(), 500);
    }
  };
};
```

### Custom Input Validation

```tsx
const validateCustomInput = (text: string): boolean => {
  // Trim whitespace
  const trimmed = text.trim();
  
  // Check for empty input
  if (!trimmed) return false;
  
  // Check character limit
  if (trimmed.length > maxLength) return false;
  
  // Note: The ChoiceSelector component handles validation internally
  // No minimum length requirement is enforced
  
  return true;
};
```

### Best Practices for Custom Input

1. **Character Limits**: Use reasonable limits (150-250 characters)
2. **Validation**: Always validate input before processing
3. **Feedback**: Provide immediate visual feedback during typing
4. **Accessibility**: Ensure keyboard navigation and screen reader support
5. **Error Handling**: Gracefully handle submission failures
6. **Context**: Provide helpful placeholder text based on game context

### Testing Custom Input

```tsx
import { render, screen, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';

test('custom input integration', async () => {
  const handleCustomSubmit = jest.fn();
  const user = userEvent.setup();
  
  render(
    <ChoiceSelector
      choices={choices}
      onSelect={jest.fn()}
      enableCustomInput={true}
      onCustomSubmit={handleCustomSubmit}
    />
  );
  
  // Type custom action
  const input = screen.getByPlaceholderText('Type your custom response...');
  await user.type(input, 'I examine the mysterious door');
  
  // Submit and verify
  await user.click(screen.getByRole('button', { name: /submit/i }));
  expect(handleCustomSubmit).toHaveBeenCalledWith('I examine the mysterious door');
});
```

---

This guide covers both AI choice generation and custom player input integration. For detailed component documentation, see the [ChoiceSelector README](../src/components/shared/ChoiceSelector/README.md) and the [Custom Player Input feature documentation](../features/custom-player-input.md).